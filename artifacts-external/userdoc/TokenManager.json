{
  "methods": {
    "assign(address,uint256)": {
      "notice": "Assign `@tokenAmount(self.token(): address, _amount, false)` tokens to `_receiver` from the Token Manager's holdings"
    },
    "assignVested(address,uint256,uint64,uint64,uint64,bool)": {
      "notice": "Assign `@tokenAmount(self.token(): address, _amount, false)` tokens to `_receiver` from the Token Manager's holdings with a `_revokable : 'revokable' : ''` vesting starting at `@formatDate(_start)`, cliff at `@formatDate(_cliff)` (first portion of tokens transferable), and completed vesting at `@formatDate(_vested)` (all tokens transferable)"
    },
    "burn(address,uint256)": {
      "notice": "Burn `@tokenAmount(self.token(): address, _amount, false)` tokens from `_holder`"
    },
    "forward(bytes)": {
      "notice": "Execute desired action as a token holder"
    },
    "initialize(address,bool,uint256)": {
      "notice": "Initialize Token Manager for `_token.symbol(): string`, whose tokens are `transferable ? 'not' : ''` transferable`_maxAccountTokens > 0 ? ' and limited to a maximum of ' + @tokenAmount(_token, _maxAccountTokens, false) + ' per account' : ''`"
    },
    "issue(uint256)": {
      "notice": "Mint `@tokenAmount(self.token(): address, _amount, false)` tokens for the Token Manager"
    },
    "mint(address,uint256)": {
      "notice": "Mint `@tokenAmount(self.token(): address, _amount, false)` tokens for `_receiver`"
    },
    "revokeVesting(address,uint256)": {
      "notice": "Revoke vesting #`_vestingId` from `_holder`, returning unvested tokens to the Token Manager"
    },
    "transferToVault(address)": {
      "notice": "Send funds to recovery Vault. This contract should never receive funds,        but in case it does, this function allows one to recover them."
    }
  }
}
